<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drag & Anchor</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: #f0f0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
    }

    .anchor {
      width: 40px;
      height: 40px;
      background: red;
      border-radius: 50%;
      position: absolute;
    }

    .ball {
      width: 50px;
      height: 50px;
      background: dodgerblue;
      border-radius: 50%;
      position: absolute;
      touch-action: none;
      transition: left 0.6s ease-in-out, top 0.6s ease-in-out;
    }
  </style>
</head>
<body>
  <script>
    const numBalls = 3; // Numero di palline (modificabile)
    const numAnchors = 6; // Numero fisso di punti di ancoraggio
    const anchors = [];
    const balls = [];
    const anchorRadius = 150; // Raggio del cerchio su cui posizionare le ancore
    const anchorSize = 60; // Definisci la larghezza dei punti di ancoraggio (diametro)
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    let totalCost = 0;
    const maxCost = 10;

    // Crea i punti di ancoraggio disposti in cerchio
    for (let i = 0; i < numAnchors; i++) {
        const angle = (2 * Math.PI / numAnchors) * i;
        const x = centerX + anchorRadius * Math.cos(angle) - 20;
        const y = centerY + anchorRadius * Math.sin(angle) - 20;

        const anchor = document.createElement('div');
        anchor.className = 'anchor';
        anchor.style.left = `${x}px`;
        anchor.style.top = `${y}px`;
        anchor.style.width = `${anchorSize}px`; // Imposta la larghezza
        anchor.style.height = `${anchorSize}px`;
        document.body.appendChild(anchor);
        anchors.push(anchor);
    }

    // Crea le palline e ne gestisce l'interazione
    for (let i = 0; i < numBalls; i++) {

        const ball = document.createElement('div');
        ball.className = 'ball';
        const origin = { left: 100 + i * 70, top: 100 }; // Posizione iniziale delle palline
        // Costo della pallina, attualmente randomico
        const cost = Math.floor(Math.random() * 10) + 1;;
        ball.style.left = `${origin.left}px`;
        ball.style.top = `${origin.top}px`;
        ball.innerHTML = `${cost}`;

        let isDragging = false;
        let anchoredTo = null; // Memorizza se la pallina è ancorata
        let offset = { x: 0, y: 0 };

        // Ottiene le coordinate corrette per mouse o touch
        const getEventCoords = (e) => {
            if (e.touches) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else {
            return { x: e.clientX, y: e.clientY };
            }
        };

        // Inizia il trascinamento
        const onStart = (e) => {
            e.preventDefault();
            isDragging = true;
            ball.style.transition = 'none'; // Disabilita animazione durante il trascinamento
            // Vengono prese le coordinate dell'evento di tocco o click e vengono applicate 
            // all'interno dell'offset rispettivo della pallina. Questo fa in modo che la pallina non snappi
            // al tocco, ma che venga trascinata dal punto in cui è stata cliccata
            const coords = getEventCoords(e);
            const rect = ball.getBoundingClientRect();
            offset.x = coords.x - rect.left;
            offset.y = coords.y - rect.top;
        };

        // Aggiorna la posizione della pallina durante il trascinamento
        const onMove = (e) => {
            // Se la pallina non sta venendo trascinata la funzione ritorna
            if (!isDragging) return;
            // Altrimenti applica la nuova posizione con differita di offset, 
            // per rendere il movimento fluido ed evitare snapping orribili
            const coords = getEventCoords(e);
            ball.style.left = `${coords.x - offset.x}px`;
            ball.style.top = `${coords.y - offset.y}px`;
            
        };

        // Quando il trascinamento termina
        const onEnd = () => {
            if (!isDragging) return;
            isDragging = false;

            const ballRect = ball.getBoundingClientRect();
            let closestAnchor = null;
            let minDist = Infinity;

            // Trova l'ancora più vicina alla pallina
            for (const anchor of anchors) {
                const anchorRect = anchor.getBoundingClientRect();
                const dx = (ballRect.left + ballRect.width / 2) - (anchorRect.left + anchorRect.width / 2);
                const dy = (ballRect.top + ballRect.height / 2) - (anchorRect.top + anchorRect.height / 2);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < minDist) {
                    minDist = dist;
                    closestAnchor = anchor;
                }
            }

            const snapDistance = 40; // Distanza massima per ancorarsi

            
            // Se vicino all'ancora
            if (minDist < snapDistance) {
                
                // Vengono fatti dei controlli per vedere se la pallina era già ancorata
                // al fine di gestire i costi

                // Pallina non ancora ancorata
                if(!anchoredTo){
                    // Se il costo della pallina è sommabile viene inserita aumentando il costo occupato
                    if(cost + totalCost <= maxCost){
                        totalCost += cost;
                    
                    // Se il costo della pallina supera il costo totale non viene inserita
                    // E viene riportata al punto di partenza
                    } else {
                        ball.style.transition = 'left 0.6s ease-in-out, top 0.6s ease-in-out';
                        ball.style.left = `${origin.left}px`;
                        ball.style.top = `${origin.top}px`;
                        return;
                    }
                }

                anchoredTo = closestAnchor;
                ball.style.transition = 'left 0.3s ease, top 0.3s ease';
                // Calcola il centro del punto di ancoraggio
                const anchorCenterX = anchoredTo.offsetLeft + anchoredTo.offsetWidth / 2;
                const anchorCenterY = anchoredTo.offsetTop + anchoredTo.offsetHeight / 2;

                // Posiziona la pallina in modo che il suo centro coincida con il centro dell'ancora
                ball.style.left = `${anchorCenterX - ball.offsetWidth / 2}px`;
                ball.style.top = `${anchorCenterY - ball.offsetHeight / 2}px`;

                console.log(`Pallina ${i + 1} ancorata con costo ${cost}. Costo occupato: ${totalCost}.`);
            
            } else {
                // Se era ancorata, ora viene rimossa e si invia un segnale
                if (anchoredTo) {
                    // Viene rimosso il costo della pallina dal costo totale
                    totalCost -= cost;
                    // Log per il debug
                    console.log(`Pallina ${i + 1} rimossa dall'ancoraggio. Costo occupato: ${totalCost}.`);
                }

                // A prescindere la pallina viene riportata al punto di partenza
                anchoredTo = null;
                ball.style.transition = 'left 0.6s ease-in-out, top 0.6s ease-in-out';
                ball.style.left = `${origin.left}px`;
                ball.style.top = `${origin.top}px`;
            
            }
        };

        // Eventi per mouse e touch
        ball.addEventListener('mousedown', onStart);
        ball.addEventListener('touchstart', onStart);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('touchmove', onMove);
        document.addEventListener('mouseup', onEnd);
        document.addEventListener('touchend', onEnd);

        // Clic per far tornare la pallina alla posizione iniziale se non ancorata
        ball.addEventListener('click', () => {
            if (!anchoredTo) {
                ball.style.transition = 'left 0.6s ease-in-out, top 0.6s ease-in-out';
                ball.style.left = `${origin.left}px`;
                ball.style.top = `${origin.top}px`;
            }
        });

        balls.push(ball);
        document.body.appendChild(ball);
    }
  </script>
</body>
</html>